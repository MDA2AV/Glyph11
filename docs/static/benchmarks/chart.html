<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Glyph11 Benchmark Trends</title>
  <style>
    html {
      font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      background-color: #fff;
      font-size: 16px;
    }
    body { color: #4a4a4a; margin: 16px; font-weight: 400; }
    h2 { margin-top: 2em; color: #333; border-bottom: 1px solid #e5e7eb; padding-bottom: .3em; }
    h3 { color: #555; margin-top: 1.5em; }
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(540px, 1fr));
      gap: 24px;
      margin: 16px 0;
    }
    .chart-card {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      background: #fafafa;
    }
    .chart-card h4 {
      margin: 0 0 12px 0;
      font-size: 0.95em;
      color: #333;
    }
    .legend { font-size: 0.8em; color: #666; margin-top: 8px; }
    .legend span { margin-right: 16px; }
    .legend .timing-dot { color: #178600; }
    .legend .alloc-dot { color: #3273dc; }
    #loading { text-align: center; padding: 2em; color: #888; }
  </style>
</head>
<body>

<div id="loading"><em>Loading benchmark data...</em></div>
<div id="content" style="display:none">
  <div id="parser-section"></div>
  <div id="semantics-section"></div>
</div>

<script src="data.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js"
        integrity="sha384-jb8JQMbMoBUzgWatfe6COACi2ljcDdZQ2OxczGA3bGNeWe+6DChMTBJemed7ZnvJ"
        crossorigin="anonymous"></script>
<script>
(function () {
  const loading = document.getElementById('loading');
  const content = document.getElementById('content');

  if (!window.BENCHMARK_DATA) {
    loading.innerHTML = '<em>Could not load benchmark data.</em>';
    return;
  }

  const entries = window.BENCHMARK_DATA.entries['Benchmark'];
  if (!entries || entries.length === 0) {
    loading.innerHTML = '<em>No benchmark entries found.</em>';
    return;
  }

  loading.style.display = 'none';
  content.style.display = 'block';

  // Collect all benchmark names across all entries
  const allNames = new Set();
  entries.forEach(e => e.benches.forEach(b => allNames.add(b.name)));

  // Separate timing benchmarks from .Allocated companions
  const timingNames = [];
  const allocNames = new Set();
  allNames.forEach(name => {
    if (name.endsWith('.Allocated')) {
      allocNames.add(name);
    } else {
      timingNames.push(name);
    }
  });
  timingNames.sort();

  // Group by benchmark class
  const groups = {};
  timingNames.forEach(name => {
    const parts = name.split('.');
    // e.g. Benchmarks.FlexibleParserBenchmark.Small_ROM
    const className = parts.length >= 3 ? parts.slice(0, parts.length - 1).join('.') : 'Other';
    if (!groups[className]) groups[className] = [];
    groups[className].push(name);
  });

  // Labels (commit short hashes)
  const labels = entries.map(e => {
    const id = e.commit ? e.commit.id : '';
    return id ? id.substring(0, 7) : '?';
  });

  // Commit details for tooltips
  const commitDetails = entries.map(e => {
    if (!e.commit) return { message: '', date: '' };
    return {
      message: (e.commit.message || '').split('\n')[0],
      date: e.commit.timestamp || '',
    };
  });

  function getValues(benchName) {
    return entries.map(e => {
      const b = e.benches.find(b => b.name === benchName);
      return b ? b.value : null;
    });
  }

  function getRanges(benchName) {
    return entries.map(e => {
      const b = e.benches.find(b => b.name === benchName);
      if (!b || !b.range) return 0;
      return parseFloat(b.range.replace(/[^0-9.]/g, '')) || 0;
    });
  }

  function shortName(fullName) {
    const parts = fullName.split('.');
    return parts[parts.length - 1];
  }

  function formatBytes(bytes) {
    if (bytes === null || bytes === undefined) return '\u2014';
    if (bytes === 0) return '0 B';
    if (bytes < 1024) return bytes.toFixed(0) + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  }

  function formatNs(ns) {
    if (ns === null || ns === undefined) return '\u2014';
    if (ns >= 1e6) return (ns / 1e6).toFixed(2) + ' ms';
    if (ns >= 1e3) return (ns / 1e3).toFixed(2) + ' \u00b5s';
    return ns.toFixed(1) + ' ns';
  }

  function createChart(container, benchName) {
    const allocName = benchName + '.Allocated';
    const hasAlloc = allocNames.has(allocName);
    const timingData = getValues(benchName);
    const timingRanges = getRanges(benchName);
    const allocData = hasAlloc ? getValues(allocName) : null;

    const card = document.createElement('div');
    card.className = 'chart-card';

    const title = document.createElement('h4');
    title.textContent = shortName(benchName);
    card.appendChild(title);

    const wrapper = document.createElement('div');
    wrapper.style.position = 'relative';
    wrapper.style.height = '200px';
    const canvas = document.createElement('canvas');
    wrapper.appendChild(canvas);
    card.appendChild(wrapper);

    if (hasAlloc) {
      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = '<span class="timing-dot">\u25cf</span> Timing (ns)' +
        ' &nbsp; <span class="alloc-dot">\u25cf</span> Allocated (bytes)';
      card.appendChild(legend);
    }

    container.appendChild(card);

    const datasets = [
      {
        label: 'Timing',
        data: timingData,
        borderColor: '#178600',
        backgroundColor: 'rgba(23, 134, 0, 0.1)',
        borderWidth: 2,
        pointRadius: 3,
        pointHoverRadius: 5,
        tension: 0.1,
        yAxisID: 'y',
        spanGaps: true,
      }
    ];

    const scales = {
      x: {
        ticks: { maxRotation: 45, font: { size: 10 } },
      },
      y: {
        type: 'linear',
        position: 'left',
        title: { display: true, text: 'Time (ns)', color: '#178600' },
        ticks: { color: '#178600' },
        grid: { color: 'rgba(23, 134, 0, 0.08)' },
        beginAtZero: true,
      },
    };

    if (hasAlloc) {
      datasets.push({
        label: 'Allocated',
        data: allocData,
        borderColor: '#3273dc',
        backgroundColor: 'rgba(50, 115, 220, 0.1)',
        borderWidth: 2,
        borderDash: [5, 3],
        pointRadius: 3,
        pointHoverRadius: 5,
        tension: 0.1,
        yAxisID: 'y1',
        spanGaps: true,
      });
      scales.y1 = {
        type: 'linear',
        position: 'right',
        title: { display: true, text: 'Allocated (B)', color: '#3273dc' },
        ticks: { color: '#3273dc' },
        grid: { drawOnChartArea: false },
        beginAtZero: true,
      };
    }

    new Chart(canvas, {
      type: 'line',
      data: { labels: labels, datasets: datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: function (ctx) {
                const i = ctx[0].dataIndex;
                const d = commitDetails[i];
                return labels[i] + (d.message ? ' \u2014 ' + d.message : '');
              },
              label: function (ctx) {
                if (ctx.dataset.yAxisID === 'y1') {
                  return 'Allocated: ' + formatBytes(ctx.parsed.y);
                }
                const range = timingRanges[ctx.dataIndex];
                return 'Timing: ' + formatNs(ctx.parsed.y) + (range ? ' \u00b1 ' + formatNs(range) : '');
              },
            },
          },
        },
        scales: scales,
      },
    });
  }

  // Render sections
  const sectionConfig = [
    { key: 'Benchmarks.FlexibleParserBenchmark', heading: 'FlexibleParser', target: 'parser-section' },
    { key: 'Benchmarks.HardenedParserBenchmark', heading: 'HardenedParser', target: 'parser-section' },
    { key: 'Benchmarks.RequestSemanticsBenchmark', heading: 'RequestSemantics', target: 'semantics-section' },
  ];

  const rendered = new Set();

  sectionConfig.forEach(sec => {
    const benchmarks = groups[sec.key];
    if (!benchmarks || benchmarks.length === 0) return;

    const section = document.getElementById(sec.target);
    const heading = document.createElement('h2');
    heading.textContent = sec.heading;
    section.appendChild(heading);

    const grid = document.createElement('div');
    grid.className = 'chart-grid';
    section.appendChild(grid);

    benchmarks.forEach(name => {
      createChart(grid, name);
      rendered.add(name);
    });
  });

  // Render any ungrouped benchmarks
  const ungrouped = timingNames.filter(n => !rendered.has(n));
  if (ungrouped.length > 0) {
    const section = document.getElementById('parser-section');
    const heading = document.createElement('h2');
    heading.textContent = 'Other Benchmarks';
    section.appendChild(heading);
    const grid = document.createElement('div');
    grid.className = 'chart-grid';
    section.appendChild(grid);
    ungrouped.forEach(name => createChart(grid, name));
  }
})();
</script>
</body>
</html>
